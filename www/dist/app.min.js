;(function() {
"use strict";

angular.module('tracker', 
    ['ionic', 'ngAnimate', 'ngCordova', 'angularMoment', 'ngMaterial']);

angular.module('tracker')
  .constant('API', {
      endpoint: 'https://sandbox.1self.co',
      appName: 'co.1self.universaltracker',
      appVersion: '0.0.1',
      appId: 'app-id-556d18e5ed9e4e67343332987f73a360',
      appSecret: 'app-secret-0f5d09051e0bda5869e1a866bb4bc62afe30ae70fc8be92313a6e25ecc7d07db'
  })
  .constant('appName', '1self Tracker')
  .run(["$ionicPlatform", "AuthenticationService", "EventSendService", function($ionicPlatform, AuthenticationService, EventSendService) {
      $ionicPlatform.ready(function() {
        if (window.plugin && window.plugin.notification) {
          window.plugin.notification.local.promptForPermission();
        }

        if (window.cordova && window.cordova.InAppBrowser) {
          window.open = window.cordova.InAppBrowser.open;  
        }
          
          if(AuthenticationService.authenticated()){
              EventSendService.sendEvents();
          }else{
              AuthenticationService.authenticate();
          }

          // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
          // for form inputs)
          if (window.cordova && window.cordova.plugins.Keyboard) {
              //Change this to false to return accessory bar 
              cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
          }
          if (window.StatusBar) {
              StatusBar.styleDefault();
          }
      })
  }]);

angular.module('tracker')
	.config(config);

function config($ionicConfigProvider, $mdGestureProvider) {
    $ionicConfigProvider.navBar.alignTitle('center');
    $ionicConfigProvider.tabs.position('top');
    $ionicConfigProvider.backButton.text('back');
    $mdGestureProvider.skipClickHijack();
	$ionicConfigProvider.views.maxCache(0);
}
config.$inject = ["$ionicConfigProvider", "$mdGestureProvider"];
angular.module('tracker')
	.config(routesConfig);

function routesConfig($stateProvider, $urlRouterProvider) {
  $stateProvider
      .state('tab', {
          url: "/tab",
          abstract: true,
          templateUrl: "templates/tabs.html"
      })
        .state('tab.dash', {
            url: '/dash',
            views: {
                'tab-dash': {
                    templateUrl: 'dash/dash.html',
                    controller: 'DashCtrl as vm'
                }
            }
        })
        .state('tab.edit', {
            url: '/dash/edit',
            views: {
                'tab-dash': {
                    templateUrl: 'dash/dash-edit.html',
                    controller: 'DashEditCtrl as vm'
                }
            }
        })
        .state('tab.history', {
            url: '/history',
            views: {
                'tab-history': {
                    templateUrl: 'history/history.html',
                    controller: 'HistoryCtrl as vm'
                }
            }
        })
        .state('tab.charts', {
            url: '/charts',
            views: {
                'tab-charts': {
                    templateUrl: 'charts/charts.html',
                    controller: 'ChartCtrl as vm'
                }
            }
        })
      .state('add-activity', {
        url: '/add',
        abstract: true,
        templateUrl: 'add/add.html'
      })
        .state('add-activity.name', {
          url: '/name',
          templateUrl: 'add/name.html',
          controller: 'AddCtrl as vm'
        })
        .state('add-activity.select-name', {
          url: '/select-name',
          templateUrl: 'add/select-name.html',
          controller: 'AddCtrl as vm'
        })
        .state('add-activity.type', {
          url: '/type',
          templateUrl: 'add/type.html',
          controller: 'AddCtrl as vm'
        })
        .state('add-activity.duration', {
          url: '/duration',
          templateUrl: 'add/duration.html',
          controller: 'AddCtrl as vm'
        })
      ;

  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/tab/dash');
}
routesConfig.$inject = ["$stateProvider", "$urlRouterProvider"];
angular.module('tracker')
	.controller('ChartCtrl', ChartCtrl);

function ChartCtrl(oneSelfService, $location, activityService, AuthenticationService) {
	var vm = this;

    vm.activities = activityService.getActivities();
    vm.chart = {};
    vm.showChart = showChart;

    function init() {
        if (!AuthenticationService.authenticated()) {
            AuthenticationService.authenticate(true, function(res) {
                if (!res) $location.path('/dash');
            });
        }
    };
    init();

    function showChart(name) {
    	var type = _.find(vm.activities, { 'name': name }).type;
		var url = oneSelfService.getChartUrl(name, type)
        window.open(url, '_system', 'location=no');
    };
}
ChartCtrl.$inject = ["oneSelfService", "$location", "activityService", "AuthenticationService"];
angular.module('tracker')
	.directive('utClick', click);

// this exists to prevent the 'double click' issue when ngTouch is used
function click() {
    return function(scope, element, attrs) {
        element.bind('touchstart click', function(event) {
            event.preventDefault();
            event.stopPropagation();

            scope.$apply(attrs['utClick']);
        });
    };
}

angular.module('tracker')
	.directive('utCountdownActivity', countdownActivity);

function countdownActivity() {
	return {
		templateUrl: 'components/countdown.directive.html'
	};
}
angular.module('tracker')
	.directive('utDurationActivity', durationActivity);

function durationActivity() {
	return {
		templateUrl: 'components/duration.directive.html'
	};
}
angular.module('tracker')
	.directive('utMultiActivity', multiActivity);

function multiActivity() {
	return {
		templateUrl: 'components/multi.directive.html'
	};
}
angular.module('tracker')
	.directive('utNote', note);

function note() {
	return {
		templateUrl: 'components/note.directive.html'
	};
}
angular.module('tracker')
  .directive('utRestrict', restrict);

function restrict() {
  return {
    require: '?ngModel',
    restrict: 'A',
    link: function(scope, element, attributes, ngModelCtrl) {
      if(!ngModelCtrl) {
        return; 
      }

      var match = new RegExp(attributes.utRestrict, 'g');

      ngModelCtrl.$parsers.push(function(val) {
        var asString = (val) ? val.toString() : '';
        var clean = asString.match(match) ? asString.match(match).join('') : '';

        if (clean !== asString) {
          ngModelCtrl.$setViewValue(clean);
          ngModelCtrl.$render();
        }
        return clean;
      });
    }
  };
}
angular.module('tracker')
    .directive('utSelectOnClick', selectOnClick);

function selectOnClick($window) {
    return {
        restrict: 'A',
        link: function (scope, element, attrs) {
            element.bind('mouseup', function () {
                this.setSelectionRange(0, this.value.length);
            });
        }
    }
}
selectOnClick.$inject = ["$window"];

angular.module('tracker')
	.directive('utSingleActivity', singleActivity);

function singleActivity() {
	return {
		templateUrl: 'components/single.directive.html'
	};
}
angular.module('tracker')
	.directive('utTime', time);

function time(durationService) {
	return {
		restrict: 'E',
		templateUrl: 'components/time.directive.html',
		scope: {
			duration: '='
		},
		link: function(scope) {
			scope.isValidDuration = durationService.isValidDuration
		}
	};
}
time.$inject = ["durationService"];
angular.module('tracker')
	.directive('utClick', click);

// this exists to prevent the 'double click' issue when ngTouch is used
function click() {
    return function(scope, element, attrs) {
        element.bind('touchstart click', function(event) {
            event.preventDefault();
            event.stopPropagation();

            scope.$apply(attrs['utClick']);
        });
    };
}

angular.module('tracker')
	.controller('AddCtrl', AddCtrl);

function AddCtrl(activityService, $state, newActivityService) {
	var vm = this;

	var lastActivity;

	vm.activityTypes = activityService.getActivityTypes();
	vm.addActivity = addActivity;
	vm.newActivity = newActivityService.activity;
	vm.getDuration = getDuration;
	vm.activityInvalid = activityInvalid;
	vm.nameAlreadyExists = nameAlreadyExists;

	function getDuration() {
		return vm.newActivity.duration.hours * 3600000 
			+ vm.newActivity.duration.minutes * 60000 
			+ vm.newActivity.duration.seconds * 1000;
	}

	function addActivity() {
		if (lastActivity === vm.newActivity) return;
		lastActivity = vm.newActivity;

		var duration = getDuration();

		activityService.add({
			name: vm.newActivity.name,
			type: vm.newActivity.type,
			duration: duration,
			remaining: duration,
		});

		newActivityService.activity = { duration: { hours: 0, minutes: 0, seconds: 0 }};
		$state.go('tab.dash');
	}

	function activityInvalid() {
		return !vm.newActivity.name || nameAlreadyExists();
	}

	function nameAlreadyExists() {
		if (!vm.newActivity.name) return false;

		var activities = activityService.getActivities();
		return _.find(activities, 'name', vm.newActivity.name);
	}
}
AddCtrl.$inject = ["activityService", "$state", "newActivityService"];
angular.module('tracker')
    .filter('durationPartFilter', function() {
        return function(str) {
            return str.substr(0, 8);
        }
    })
    .filter('tenthsPartFilter', function() {
        return function(str) {
            return str.substr(9, str.length);
        }
    })
    .filter('buildEventFilter', function() {
        return function(activity) {
            return {
                "activity": activity.title,
                "dateTime": activity.startDate,
                "duration": activity.duration/1000
            };
        };
    });
angular.module('tracker')
    .filter('humanize', humanize);

function humanize(moment) {
    moment.locale('en', {
        calendar: {
            lastDay: '[Yesterday]',
            sameDay: '[Today]',
            lastWeek: '[Last] dddd LL',
            sameElse: 'LL'
        }
    });

    return function(date) {
        return moment(date).calendar();
    };
}
humanize.$inject = ["moment"];
angular.module('tracker')
    .filter('millisecondsToStringFilter', millisecondsToStringFilter);

function millisecondsToStringFilter() {
    return function(milliseconds) {
        if (milliseconds !== 0 && !milliseconds) return "";

        var seconds = Math.floor(milliseconds / 1000);
        milliseconds = Math.floor((milliseconds % 1000) / 100);
        var minutes = Math.floor(seconds / 60);
        seconds = seconds - (minutes * 60);
        var hours = Math.floor(minutes / 60);
        minutes = minutes - (hours * 60);

        var zeroPad = function(num, numZeros) {
            var n = Math.abs(num);
            var zeros = Math.max(0, numZeros - Math.floor(n).toString().length);
            var zeroString = Math.pow(10, zeros).toString().substr(1);
            if (num < 0) {
                zeroString = '-' + zeroString;
            }
            return zeroString + n;
        }

        var durationString = '';
        durationString += zeroPad(hours, 2) + ':' + zeroPad(minutes, 2) + ':' + zeroPad(seconds, 2) + ":" + zeroPad(milliseconds, 2);
        return durationString;
    };
}
angular.module('tracker')
	.factory('oneSelfService', oneSelfService);

function oneSelfService(API) {
    var lib1self = new Lib1selfClient(API, "sandbox");

    var stream;
    lib1self.fetchStream(function(err, response) {
        stream = response;
    });

	return {
		sendEventToApi: sendEventToApi,
		getChartUrl: getChartUrl
	};

	function sendEventToApi(event) {
		var eventToLog = {
            source: API.appName,
            version: API.appVersion,
            objectTags: ["self"],
            actionTags: clean(event.event),
            properties: { }
        };

        if (event.note) {
            eventToLog.note = event.note;
            var hashtags = getHashtags(event.note);
            if (hashtags) eventToLog.properties.tags = hashtags;
        }

        if (event.amount) { 
            eventToLog.properties.quantity = event.amount;
        } else {
            eventToLog.properties.duration = event.duration / 1000;
        }

        lib1self.sendEvent(eventToLog, stream);
	}

	function getChartUrl(actionTag, type) {
        var sum = (type === 'single' || type === 'multi') ? 'quantity' : 'duration';

		var url = lib1self
            .objectTags(["self"])
            .actionTags([actionTag])
            .sum(sum)
            .barChart()
            .backgroundColor("00B8E7")
            .url(stream);

        return url;
	}

    function clean(event) {
        return event.toLowerCase().replace(' ', '-');
    }

    function getHashtags(note) {
        return [
            'flatwhite'
        ];
    }
}
oneSelfService.$inject = ["API"];
angular.module('tracker')
	.factory('activityService', activityService);

function activityService($filter) {
    var activities = loadActivities();
    var activityTypes = [
        "Coding",
        "Commuting",
        "Excercising",
        "Meditating",
        "Meetings",
        "Partying",
        "Playing Instrument",
        "Playing Games",
        "Reading",
        "Sitting",
        "Sleeping",
        "Standing",
        "Studying",
        "Tooth Brushing",
        "Tooth Flossing",
        "TV Watching ",
        "Working",
        "Writing"
    ];

	return {
		moveItem: moveItem,
		getActivities: getActivities,
		add: add,
		remove: remove,
        getActivityTypes: getActivityTypes,
        getActionTags: getActionTags,
        getDurationSplit: getDurationSplit
	};

    function loadActivities() {
        if (window.localStorage.activities) {
            return JSON.parse(window.localStorage.activities);
        } else {
            return [
                { name: 'Push ups', type: 'multi' },
                { name: 'Drank a coffee', type: 'single' },
                { name: 'Commuting', type: 'duration', duration: 0 },
                { name: 'Meditating', type: 'countdown', duration: 600000, remaining: 600000 }
            ];
        }
    }

    function getActivityTypes() {
        var currentActivityNames = _.map(getActivities(), 'name');
        var filtered = _.filter(activityTypes, function(type) {
            return !_.includes(currentActivityNames, type);
        });
        return filtered;
    }

    function getActionTags() {
        return [];
    }

	function moveItem(item, fromIndex, toIndex) {
    	activities.splice(fromIndex, 1);
    	activities.splice(toIndex, 0, item);
		save();
    }

    function getActivities() {
        return activities;
    }

    function add(activity) {
    	activities.push(activity);
   		save();
    }

    function remove(index) {
    	activities.splice(index, 1);
    	save();
    }

    function save() {
   		window.localStorage.activities = JSON.stringify(activities);
    }

    function getDurationSplit(activity) {
        var durationString = $filter('millisecondsToStringFilter')(activity.duration);
        var durationParts = durationString.split(':');

        return {
            duration: {
                hours: parseInt(durationParts[0], 10),
                minutes: parseInt(durationParts[1], 10),
                seconds: parseInt(durationParts[2], 10),
                milliseconds: parseInt(durationParts[3], 10)
            }
        };
    }
}
activityService.$inject = ["$filter"];

angular.module('tracker')
    .service('activityTimingService', activityTimingService);

function activityTimingService(moment, $interval, NotificationService, historyService) {
    return {
        toggleActivity: toggleActivity,
        toggleCountdownActivity: toggleCountdownActivity
    };
    

    function toggleActivity(activity) {
        if (!activity.interval) {
            NotificationService.showNotification();
            activity.startDate = moment();
            updateActivityTime();
            activity.interval = $interval(updateActivityTime, 100);
            storeActiveActivity(activity);
        } else {
            NotificationService.cancelNotification();
            $interval.cancel(activity.interval);
            delete activity.interval;
            removeActiveActivity(activity);
        }

        function updateActivityTime() {
            var elapsedTime = moment.duration(moment().diff(activity.startDate));
            activity.duration = elapsedTime.asMilliseconds();
        };

        function updateActiveActivity() {
            var active_activities = getActiveActivities();
            if(activity.title in active_activities){
                activity.startDate = active_activities[activity.title].startDate;

                //cancel any previous intervals (if, any)
                $interval.cancel(activity.interval);

                //create new
                updateActivityTime();
                activity.interval = $interval(updateActivityTime, 100);
            }
        };

        return activity;
    };

    function toggleCountdownActivity(activity) {
        if (!activity.interval) {
            NotificationService.showNotification();
            activity.startDate = moment();
            activity.endDate = moment().add(activity.duration, 'ms');
            updateActivityTime();
            activity.interval = $interval(updateActivityTime, 100);
            storeActiveActivity(activity);
        } else {
            NotificationService.cancelNotification();
            $interval.cancel(activity.interval);
            delete activity.interval;
            removeActiveActivity(activity);
        }

        function updateActivityTime() {
            if (activity.remaining > 100) {
                var timeRemaining = moment.duration(moment(activity.endDate).diff(moment()));
                activity.remaining = timeRemaining.asMilliseconds();
            } else {
                var duration = moment.duration(moment().diff(activity.startDate));
                historyService.add({event:activity.name, duration:duration.asMilliseconds()});

                $interval.cancel(activity.interval);
                activity.remaining = activity.duration;
                delete activity.interval;
                removeActiveActivity(activity);
            }
        };
    }

    // --- privates --- //

    function storeActiveActivity(activity) {
        var active_activities = getActiveActivities();
        active_activities[activity.title] = {startDate: activity.startDate};
        window.localStorage.active_activities = angular.toJson(active_activities);
    };

    function removeActiveActivity(activity) {
        var active_activities = getActiveActivities();
        delete active_activities[activity.title];
        window.localStorage.active_activities = angular.toJson(active_activities);
    };

    function getActiveActivities() {
        var active_activities = window.localStorage.active_activities;
        if (active_activities) {
            return angular.fromJson(active_activities);
        } else {
            return {};
        }
    };
}
activityTimingService.$inject = ["moment", "$interval", "NotificationService", "historyService"];
angular.module('tracker')
    .factory('AuthenticationService', AuthenticationService);

function AuthenticationService($http, API, $ionicPopup, toastService, EventSendService) {
    var auth_headers = {
        'Authorization': API.appId + ":" + API.appSecret
    };
    
    return {
        authenticate: showDisclaimer,
        authenticated: authenticated
    };

    function showDisclaimer(force_show, callback) {
        var onConfirm = function(res) {
            if (res) {
                console.log("Authenticated, yay!");
                registerStream();
                toastService.show("Authenticating...", 'long', 'bottom'); 
            } else {
                window.localStorage.api_credentials = 'Not authenticated';
                console.log('Not authenticated :(');
            }
            if(callback) callback(res);
        };
        var api_credentials = window.localStorage.api_credentials;

        if (typeof api_credentials === 'undefined' || force_show) {
            var confirmPopup = $ionicPopup.confirm({
                title: 'Duration Data Policy',
                template: "<style>.button-continue{background-color: #00b8e7;}</style><p>1self Duration uses the 1self cloud to show you smart visualizations of your activity. Once connected you can also share and correlate your data. Your raw data will never be shown and it won't be possible to tell who you are or where you've been. Would you like to connect Duration to the 1self cloud?</p>",
                buttons: [{
                    text: 'No thanks',
                    onTap: function(e) {
                        onConfirm(false);
                    }
                }, {
                    text: 'Continue',
                    type: 'button-continue',
                    onTap: function(e) {
                        onConfirm(true);
                    }
                }]
            });
        }
    };

    
    function registerStream() {
        $http.post(API.endpoint + "/v1/streams", {}, {
            headers: auth_headers
        })
        .success(function(data) {
            window.localStorage.api_credentials = angular.toJson(data);
            window.localStorage.last_event_sent_index = -1;

            //a continuous service to send pending events
            EventSendService.sendEvents();

            toastService.show("Authenticated", 'long', 'bottom');
        })
        .error(function(data, status, headers, config) {
            //try again next time :(
        });
    };

    function authenticated() {
        var api_credentials = window.localStorage.api_credentials;
        return (api_credentials !== "Not authenticated") && (typeof api_credentials !== 'undefined');
    };
}
AuthenticationService.$inject = ["$http", "API", "$ionicPopup", "toastService", "EventSendService"];
angular.module('tracker')
	.factory('durationService', durationService);

function durationService() {
	return {
		isValidDuration: isValidDuration
	};

	function isValidDuration(duration) {
		if (duration && (
			duration.hours > 0 || 
			duration.minutes > 0 || 
			duration.seconds > 0)
			) return true;

		return false;
	}
}

angular.module('tracker')
    .service('EventSendService', EventSendService);

function EventSendService($http, $timeout, API, $filter) {
    var getQueue = function() {
        var queueString = window.localStorage.events;
        if (queueString) {
            return angular.fromJson(queueString);
        } else {
            return [];
        }
    },

    queueEvent = function(activity) {
        var queue = getQueue();
        queue.push(activity);
        window.localStorage.events = angular.toJson(queue);
    },

    getLastSentIndex = function(){
        var last_event_sent_index = window.localStorage.last_event_sent_index;
        if(typeof last_event_sent_index === 'undefined'){
            return -1;
        }else{
            return parseInt(last_event_sent_index, 10);
        }
    },

    updateLastSentIndex = function(number_of_sent) {
        var last_index = getLastSentIndex(),
        new_last_sent_index = last_index + number_of_sent;
        window.localStorage.last_event_sent_index = new_last_sent_index;
    },


    getUnsentEvents = function() {
        var queue = getQueue(),
        last_event_sent_index = getLastSentIndex(),
        queue_length = queue.length;

        return queue.slice(last_event_sent_index + 1, queue_length);
    },

    sendEvents = function() {
        var api_credentials = angular.fromJson(window.localStorage.api_credentials),
        api_headers = {
            'Authorization': api_credentials.writeToken,
            'Content-Type': 'application/json'
        },

        buildAPIEvent = function(event) {
            // var tags = ActivitiesService.getTags(event.activity);
            return {
                "dateTime": event.dateTime,
                "source": API.appName,
                "version": API.appVersion,
                // "objectTags": tags.objectTags,
                // "actionTags": tags.actionTags,
                "properties": {
                    "duration": event.duration
                }
            };
        },

        lock = false,

        poller = function() {
            var api_events = [],
            events = getUnsentEvents();

            if (0 !== events.length) {
                for (var i = 0; i < events.length; i++) {
                    api_events.push(buildAPIEvent(events[i]));
                }
                
            if (!lock) {
                lock = true;
                $http.post(API.endpoint + "/v1/streams/" + api_credentials.streamid + '/events/batch',
                        api_events, {
                            headers: api_headers
                        })
                    .success(function(data) {
                        updateLastSentIndex(api_events.length);
                        lock = false;
                    })
                    .error(function(data) {
                        lock = false;
                    });
            }
        }
            $timeout(poller, 2000);
        };

        poller();
    };

    return {
        queueEvent: queueEvent,
        sendEvents: sendEvents,
        getQueue: getQueue
    };
}
EventSendService.$inject = ["$http", "$timeout", "API", "$filter"];
angular.module('tracker')
	.factory('hashtagService', hashtagService);

function hashtagService() {
	return {
		getTags : getTags
	};

	function getTags(note) {
		return [];
	}
}
angular.module('tracker')
	.factory('newActivityService', newActivityService);

function newActivityService() {
	var activity = { duration: { hours: 0, minutes: 0, seconds: 0 }};

	return {
		activity: activity
	}
}
angular.module('tracker')
    .factory('NotificationService', NotificationService);

function NotificationService($ionicPlatform, appName){
    var id = "1";
    var count = 0;
    var message = "Timers active:";

    if (window.plugin && window.plugin.notification) {
        window.plugin.notification.local.clearAll();
    }

    if (window.localStorage.active_activities) {
        count = Object.keys(angular.fromJson(window.localStorage.active_activities)).length;
    }

    return {
        showNotification: showNotification,
        cancelNotification: cancelNotification
    };

    function showNotification() {
        if (window.plugin && window.plugin.notification) {
            $ionicPlatform.ready(function() {
                count++;
                id = window.plugin.notification.local.add({
                    id: id,
                    title: appName,
                    message: message,
                    date: new Date(),
                    ongoing: true,
                    badge: count
                });
            });
        } else {
            console.log('Notification shown');
        }
    };

    function cancelNotification() {
        if (window.plugin && window.plugin.notification) {
            $ionicPlatform.ready(function() {
                count--;
                if (count === 0) {
                    window.plugin.notification.local.cancelAll();
                }
                else {
                    window.plugin.notification.local.add({
                        id: id,
                        title: appName,
                        message: message,
                        ongoing: true,
                        sound: null,
                        badge: count});
                }
            });
        } else {
            console.log('Notification cancelled');
        }
    };
}
NotificationService.$inject = ["$ionicPlatform", "appName"];

angular.module('tracker')
	.factory('preferenceService', preferenceService);

function preferenceService() {
	var preferences = JSON.parse(window.localStorage.preferences || '{}');

	return {
		setLastAmountLogged: setLastAmountLogged,
		getLastAmountLogged: getLastAmountLogged
	}

	function setLastAmountLogged(activity, amount) {
		if (!preferences.lastAmountLogged) preferences.lastAmountLogged = {};

		preferences.lastAmountLogged[activity] = amount;
		save();
	}

	function getLastAmountLogged(activity) {
		if (!preferences.lastAmountLogged || !preferences.lastAmountLogged[activity]) {
			return 0;
		}

		return preferences.lastAmountLogged[activity];
	}

	function save() {
   		window.localStorage.preferences = JSON.stringify(preferences);
    }
}
angular.module('tracker')
	.factory('toastService', toastService);

function toastService() {
	return {
		show: show
	};

	function show(message, duration, position) {
		if (window.plugins && window.plugins.toast) {
            window.plugins.toast.show(message, duration, position);
        } else {
        	console.log('Toast: ' +message+ ' | ' +duration+ ' | ' +position)
        }
	}
}
angular.module('tracker')
	.controller('HistoryCtrl', HistoryCtrl);

function HistoryCtrl(historyService, $filter, oneSelfService) {
	var vm = this;

    vm.events = getEvents();
    vm.dates = Object.keys(getEvents()).sort().reverse();
    vm.humanizeTime = humanizeTime;
    vm.clearHistory = clearHistory;
    vm.showChart = showChart;
    vm.isLocal = (window.location.hostname === 'localhost');

    function showChart(name, type) {
        var url = oneSelfService.getChartUrl(name, type)
        window.open(url, '_system', 'location=no');
    };

    function humanizeTime(duration) {
        var tstring = $filter('millisecondsToStringFilter')(duration).split(':');
        return {
            hours: parseInt(tstring[0], 10),
            minutes: parseInt(tstring[1], 10),
            seconds: parseInt(tstring[2], 10)
        };
    };

    function getEvents() {
        var events = historyService.getQueue();
        var groups = {};
        events.forEach(function(event) {
            var date = event.when.split('T')[0];
            if (!groups[date]) {
                groups[date] = [];
            }

            // if is value and event with that event exists in groups[date]
            // add the value to existing value
            if (event.amount) {
                var sum = _.find(groups[date], { 'event': event.event });
                if (sum) {
                    sum.amount += event.amount;
                } else {                    
                    groups[date].unshift({
                        event: event.event, 
                        amount: event.amount,
                        type: event.type
                    });
                }
            } else {
                groups[date].unshift(event);
            }
        });

        return groups;
    };

    function clearHistory() {
        historyService.clear();
        vm.events = getEvents();
    }
}
HistoryCtrl.$inject = ["historyService", "$filter", "oneSelfService"];
angular.module('tracker')
	.factory('historyService', historyService);

function historyService(preferenceService, oneSelfService) {
	var history = JSON.parse(window.localStorage['history'] || '[]');
	var groupedEvents = {};

	return {
		getHistory: getHistory,
		add: add,
		getGroupedEvents: getGroupedEvents,
		getQueue: getQueue,
		queueEvent: queueEvent,
		setGroupedEvents: getGroupedEvents,
        clear: clear
	}

    function getQueue() {
        var queueString = window.localStorage.history;
        if (queueString) {
            return angular.fromJson(queueString);
        } else {
            return [];
        }
    }

    function queueEvent(activity) {
        var queue = getQueue();
        queue.push(activity);
        window.localStorage.history = angular.toJson(queue);
    }

	function getHistory() {
		return history;
	}

	function add(event) {
        event.when = new Date().toISOString();
        oneSelfService.sendEventToApi(event);
		history.push(event);
		save();
		if (event.amount) {
            preferenceService.setLastAmountLogged(event.event, event.amount);
        }
	}

	function save() {
   		window.localStorage['history'] = JSON.stringify(history);
    }

    function getGroupedEvents() {
        var events = getQueue();
        var groups = {};
        events.forEach(function(event) {
            var date = event.when.split('T')[0];
            if (!groups[date]) {
                groups[date] = [];
            }

            // if is value and event with that event exists in groups[date]
            // add the value to existing value
            if (event.amount) {
            	var sum = _.find(groups[date], { 'event': event.event });
            	if (sum) {
            		sum.amount += event.amount;
            	} else {            		
	            	groups[date].unshift({event: event.event, amount:event.amount});
            	}
            } else {
	            groups[date].unshift(event);
            }

        });

        return groups;
    };

    function clear() {
        history = [];
        window.localStorage.history = [];
    }
}
historyService.$inject = ["preferenceService", "oneSelfService"];
angular.module('tracker')
	.controller('DashEditCtrl', DashEditCtrl);

function DashEditCtrl(activityService) {
	var vm = this;

	vm.activities = activityService.getActivities();
	vm.moveItem = activityService.moveItem;
	vm.removeItem = activityService.remove;
}
DashEditCtrl.$inject = ["activityService"];
angular.module('tracker')
	.controller('DashCtrl', DashCtrl);

function DashCtrl(
	$ionicPopup, $scope, activityService, historyService, activityTimingService, 
	$filter, preferenceService, newActivityService, toastService, $ionicPopover, $state,
	appName, durationService) {
	
	var vm = this;

	var modal;

	newActivityService.activity = { duration: { hours: 0, minutes: 0, seconds: 0 }};

	vm.activities = activityService.getActivities();
	vm.logSingle = logSingle;
	vm.logMulti = logMulti;
	vm.logDuration = logDuration;
	vm.logCountdown = logCountdown;
	vm.clickSettings = clickSettings;
	vm.editActivities = editActivities;
	vm.goTo1Self = goTo1Self;
	vm.appName = appName;

	$ionicPopover.fromTemplateUrl('templates/menu.html', {
	    scope: $scope,
	    animation: ''
	}).then(function(m) {
	    modal = m;
	});

	function clickSettings() {
		modal.show();
	}

	function editActivities() {
		$state.go('tab.edit');
		modal.remove();
	}

	function goTo1Self() {
		window.open("http://www.1self.co", '_system', 'location=no');
		modal.remove();
	}

	var logDurationConfig = {
        templateUrl: 'templates/popup-log-duration.html',
        title: 'Edit duration',
        subTitle: 'Please confirm the time to log',
        scope: $scope,
        buttons: [{
            text: 'Cancel',
            onTap: function(e) { }
        }, {
            text: '<b>Log</b>',
            type: 'button-positive',
            onTap: function(e) {
            	if (durationService.isValidDuration(vm.data.duration)) {
            		e.preventDefault();	
            	}
                return vm.data.duration.hours * 3600000 + vm.data.duration.minutes * 60000 + vm.data.duration.seconds * 1000 + vm.data.duration.milliseconds;
            }
        }]
    };

	function logMulti(activity) {
		vm.amount = preferenceService.getLastAmountLogged(activity.name);

		$ionicPopup.show({
        	templateUrl: 'templates/popup-logmulti.html',
			title: 'How many '+activity.name+' did you do?',
        	scope: $scope,
        	buttons: [{
	            text: 'Cancel',
	            onTap: function(e) {
	            	return null;
	            }
	        }, {
	            text: '<b>Log</b>',
	            type: 'button-positive',
	            disabled: true,
	            onTap: function(e) {
	            	if (vm.amount <= 0) {
	            		e.preventDefault();
	            	} else {
		                return vm.amount;
		            }
	            }
	        }]
		}).then(function(response) {
			var event = {
				event: activity.name, 
				amount: response, 
				note: vm.note,
				type: activity.type
			};
			if (response) historyService.add(event);
			vm.note = '';
			var message = 'Logged ' +event.amount+ ' ' +event.event;
			toastService.show(message, 'short', 'center');
	 	});
	}

	function logSingle(activity) {
		$ionicPopup.show({
        	templateUrl: 'templates/popup-logsingle.html',
			title: 'Do you want to log a ' + activity.name + '?',
        	scope: $scope,
        	buttons: [{
	            text: 'Cancel',
	            onTap: function(e) {
	            	return false;
	            }
	        }, {
	            text: '<b>Log</b>',
	            type: 'button-positive',
	            onTap: function(e) {
	                return true;
	            }
	        }]
		}).then(function(response) {
			var event = {
				event: activity.name, 
				amount: 1, 
				note: vm.note,
				type: activity.type
			};
			if (response) historyService.add(event);
			vm.note = '';
			var message = 'Logged a single ' +event.event;
			toastService.show(message, 'short', 'center');
	 	});
	}

	function logDuration(activity) {
        var activity = activityTimingService.toggleActivity(activity);

        if (!activity.interval) {
			vm.data = getDurationSplit(activity.duration);

            $ionicPopup.show(logDurationConfig)
            .then(function(response) {
            	var event = {
            		event: activity.name, 
            		duration: response, 
            		note: vm.note,
            		type: activity.type
            	};
				if (response) historyService.add(event);
				activity.duration = 0;
				vm.note = '';
				var message = 'Logged ' +humanizeTime(event.duration)+ ' of ' +event.event;
				toastService.show(message, 'short', 'center');
            });
        }
    }

    function getDurationSplit(duration) {
    	var durationString = $filter('millisecondsToStringFilter')(duration);
        var durationParts = durationString.split(':');

		return {
            duration: {
                hours: parseInt(durationParts[0], 10),
                minutes: parseInt(durationParts[1], 10),
                seconds: parseInt(durationParts[2], 10),
                milliseconds: parseInt(durationParts[3], 10)
            }
        };
    }

	function logCountdown(activity) {
		if (!activity.interval) {
			activityTimingService.toggleCountdownActivity(activity);
		} else {
			activityTimingService.toggleCountdownActivity(activity);

			vm.data = getDurationSplit(activity.duration-activity.remaining+1000);

			$ionicPopup.show(logDurationConfig)
            .then(function(response) {
            	var event = {
            		event: activity.name, 
            		duration: response, 
            		note: vm.note,
            		type: activity.type
            	};
				
				if (response) historyService.add(event);
				activity.remaining = activity.duration;
				vm.note = '';
				var message = 'Logged ' +humanizeTime(event.duration)+ ' of ' +event.event;
				toastService.show(message, 'short', 'center');
            });
		}
	}

	function humanizeTime(duration) {
        var tstring = $filter('millisecondsToStringFilter')(duration).split(':');
        var times = {
            hours: parseInt(tstring[0], 10),
            minutes: parseInt(tstring[1], 10),
            seconds: parseInt(tstring[2], 10)
        };

        var result = '';
        if (times.hours) result += times.hours + 'h ';
        if (times.minutes) result += times.minutes + 'm ';
        if (times.seconds) result += times.seconds + 's ';

        return result;
    };
}
DashCtrl.$inject = ["$ionicPopup", "$scope", "activityService", "historyService", "activityTimingService", "$filter", "preferenceService", "newActivityService", "toastService", "$ionicPopover", "$state", "appName", "durationService"];
}());

;(function() {
"use strict";

angular.module('tracker', 
    ['ionic', 'ngAnimate', 'ngTouch','ngCordova', 'angularMoment']);

angular.module('tracker')
  .constant("API", {
      endpoint: "https://api.1self.co",
      "appName": "co.1self.duration",
      "appVersion": "1.1.4",
      "appId": "",
      "appSecret": ""
  })

  .run(function($ionicPlatform, AuthenticationService, EventSendService) {
      $ionicPlatform.ready(function() {
          //window.plugin.notification.local.promptForPermission();
          
          if(AuthenticationService.authenticated()){
              EventSendService.sendEvents();
          }else{
              AuthenticationService.authenticate();
          }

          // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard
          // for form inputs)
          if (window.cordova && window.cordova.plugins.Keyboard) {

              //Change this to false to return accessory bar 
              cordova.plugins.Keyboard.hideKeyboardAccessoryBar(false);
          }
          if (window.StatusBar) {
              StatusBar.styleDefault();
          }
      })
  });

angular.module('tracker')
	.controller('ActivityCtrl', ActivityCtrl);

function ActivityCtrl(
	$ionicPopup, $scope, activityService, historyService, activityTimingService, 
	$filter, preferenceService, popupService) {
	
	var vm = this;

	vm.activities = activityService.getActivities();
	vm.activityTypes = activityService.getActivityTypes();

	vm.addActivity = addActivity;
	vm.moveItem = activityService.moveItem;
	vm.removeItem = activityService.remove;
	vm.newActivity = {};
	vm.logSingle = logSingle;
	vm.logMulti = logMulti;
	vm.logDuration = logDuration;
	vm.logCountdown = logCountdown;

	function addActivity() {
		popupService.showAddActivityStep1($scope, function(response) {
			if (response) {
				vm.newActivity.name = response;
				popupService.showAddActivityStep2($scope, function() {
					if (vm.newActivity.name && vm.newActivity.type) {
						vm.newActivity.duration = 0;
						vm.newActivity.remaining = 0;
				   		activityService.add(vm.newActivity);
				   	}
					vm.newActivity = {};
			   	});
			}
 		});
	}

	var logDurationConfig = {
        templateUrl: 'templates/popup-log-duration.html',
        title: 'Edit duration',
        subTitle: 'Please confirm the time to log',
        scope: $scope,
        buttons: [{
            text: 'Cancel',
            onTap: function(e) {
                //activity.duration = 0;
            }
        }, {
            text: '<b>Log</b>',
            type: 'button-positive',
            onTap: function(e) {
                return vm.data.duration.hours * 3600000 + vm.data.duration.minutes * 60000 + vm.data.duration.seconds * 1000 + vm.data.duration.milliseconds;
            }
        }]
    };

	function logMulti(activity) {
		vm.amount = preferenceService.getLastAmountLogged(activity.name);

		$ionicPopup.show({
        	templateUrl: 'templates/popup-logmulti.html',
			title: 'How many '+activity.name+' did you do?',
        	scope: $scope,
        	buttons: [{
	            text: 'Cancel',
	            onTap: function(e) {
	            	return null;
	            }
	        }, {
	            text: '<b>Log</b>',
	            type: 'button-positive',
	            onTap: function(e) {
	                return vm.amount;
	            }
	        }]
		}).then(function(res) {
			if (res) historyService.add({event: activity.name, amount: res});
	 	});
	}

	function logSingle(activity) {
		$ionicPopup.alert({
			title: 'You have logged a ' + activity.name,
		}).then(function() {
			historyService.add({event: activity.name, amount: 1});
	 	});
	}

	function logDuration(activity) {
        var activity = activityTimingService.toggleActivity(activity);

        if (!activity.interval) {
			vm.data = getDurationSplit(activity);

            $ionicPopup.show(logDurationConfig).then(function(res) {
            	if (res) historyService.add({event:activity.name, duration:res});
				activity.duration = 0;
            });
        }
    }

    function getDurationSplit(activity) {
    	var durationString = $filter('millisecondsToStringFilter')(activity.duration);
        var durationParts = durationString.split(':');

		return {
            duration: {
                hours: parseInt(durationParts[0], 10),
                minutes: parseInt(durationParts[1], 10),
                seconds: parseInt(durationParts[2], 10),
                milliseconds: parseInt(durationParts[3], 10)
            }
        };
    }

	function logCountdown(activity) {
		if (!activity.interval) {
			vm.data = getDurationSplit(activity);

			$ionicPopup.show(logDurationConfig).then(function(res) {
				if (res) {
		            activity.duration = res;
					activity.remaining = activity.duration;

					activityTimingService.toggleCountdownActivity(activity);
				}
	        });	
		} else {
			var duration = moment.duration(moment().diff(activity.startDate));
			historyService.add({event:activity.name, duration:duration.asMilliseconds()});

			activityTimingService.toggleCountdownActivity(activity);
			activity.remaining = 0;
		}
	}
}
angular.module('tracker')
	.factory('activityService', activityService);

function activityService() {
    var activities = loadActivities();

	return {
		moveItem: moveItem,
		getActivities: getActivities,
		add: add,
		remove: remove,
        getActivityTypes: getActivityTypes
	};

    function loadActivities() {
        if (window.localStorage.activities) {
            return JSON.parse(window.localStorage.activities);
        } else {
            return [
                { name: 'Push ups', type: 'multi' },
                { name: 'Drank a coffee', type: 'single' },
                { name: 'Commuting', type: 'duration', duration: 0 },
                { name: 'Meditating', type: 'countdown' }
            ];
        }
    }

    function getActivityTypes() {
        return [
            "Coding",
            "Commuting",
            "Excercising",
            "Meditating",
            "Meetings",
            "Partying"
        ];
    }

	function moveItem(item, fromIndex, toIndex) {
    	activities.splice(fromIndex, 1);
    	activities.splice(toIndex, 0, item);
		save();
    }

    function getActivities() {
        return activities;
    }

    function add(activity) {
    	activities.push(activity);
   		save();
    }

    function remove(index) {
    	activities.splice(index, 1);
    	save();
    }

    function save() {
   		window.localStorage.activities = JSON.stringify(activities);
    }
}

angular.module('tracker')
    .service('activityTimingService', activityTimingService);

function activityTimingService(moment, $interval, NotificationService, historyService) {
    return {
        toggleActivity: toggleActivity,
        toggleCountdownActivity: toggleCountdownActivity
    };

    function toggleActivity(activity) {
        if (!activity.interval) {
            NotificationService.showNotification();
            activity.startDate = moment();
            updateActivityTime();
            activity.interval = $interval(updateActivityTime, 100);
            storeActiveActivity(activity);
        } else {
            NotificationService.cancelNotification();
            $interval.cancel(activity.interval);
            delete activity.interval;
            removeActiveActivity(activity);
        }

        function updateActivityTime() {
            var elapsedTime = moment.duration(moment().diff(activity.startDate));
            activity.duration = elapsedTime.asMilliseconds();
        };

        function updateActiveActivity() {
            var active_activities = getActiveActivities();
            if(activity.title in active_activities){
                activity.startDate = active_activities[activity.title].startDate;

                //cancel any previous intervals (if, any)
                $interval.cancel(activity.interval);

                //create new
                updateActivityTime();
                activity.interval = $interval(updateActivityTime, 100);
            }
        };

        return activity;
    };

    function toggleCountdownActivity(activity) {
        if (!activity.interval) {
            NotificationService.showNotification();
            activity.startDate = moment();
            activity.endDate = moment().add(activity.duration, 'ms');
            updateActivityTime();
            activity.interval = $interval(updateActivityTime, 100);
            storeActiveActivity(activity);
        } else {
            NotificationService.cancelNotification();
            $interval.cancel(activity.interval);
            delete activity.interval;
            removeActiveActivity(activity);
        }

        function updateActivityTime() {
            if (activity.remaining > 100) {
                var timeRemaining = moment.duration(moment(activity.endDate).diff(moment()));
                activity.remaining = timeRemaining.asMilliseconds();
            } else {
                var duration = moment.duration(moment().diff(activity.startDate));
                historyService.add({event:activity.name, duration:duration.asMilliseconds()});

                $interval.cancel(activity.interval);
                delete activity.interval;
                removeActiveActivity(activity);
            }
        };
    }

    // --- privates --- //

    function storeActiveActivity(activity) {
        var active_activities = getActiveActivities();
        active_activities[activity.title] = {startDate: activity.startDate};
        window.localStorage.active_activities = angular.toJson(active_activities);
    };

    function removeActiveActivity(activity) {
        var active_activities = getActiveActivities();
        delete active_activities[activity.title];
        window.localStorage.active_activities = angular.toJson(active_activities);
    };

    function getActiveActivities() {
        var active_activities = window.localStorage.active_activities;
        if (active_activities) {
            return angular.fromJson(active_activities);
        } else {
            return {};
        }
    };
}
angular.module('tracker')
	.config(routesConfig);

function routesConfig($stateProvider, $urlRouterProvider) {
  $stateProvider
      .state('tab', {
          url: "/tab",
          abstract: true,
          templateUrl: "templates/tabs.html"
      })
      .state('tab.dash', {
          url: '/dash',
          views: {
              'tab-dash': {
                  templateUrl: 'templates/tab-dash.html',
                  controller: 'ActivityCtrl as vm'
              }
          }
      })
      .state('tab.edit', {
          url: '/dash/edit',
          views: {
              'tab-dash': {
                  templateUrl: 'templates/tab-dash-edit.html',
                  controller: 'ActivityCtrl as vm'
              }
          }
      })
      .state('tab.history', {
          cache: false,
          url: '/history',
          views: {
              'tab-history': {
                  templateUrl: 'templates/tab-history.html',
                  controller: 'HistoryCtrl as vm'
              }
          }
      })
      .state('tab.charts', {
          url: '/charts',
          views: {
              'tab-charts': {
                  templateUrl: 'templates/tab-charts.html',
                  controller: 'ChartCtrl as vm'
              }
          }
      });

  // if none of the above states are matched, use this as the fallback
  $urlRouterProvider.otherwise('/tab/dash');
}
angular.module('tracker')
    .service('AuthenticationService', function($http, API, $ionicPopup, $cordovaToast, EventSendService){
    var showDisclaimer = function(force_show, callback) {
        var onConfirm = function(res) {
            if (res) {
                console.log("Authenticated, yay!");
                registerStream();
                try {
                    $cordovaToast.show("Authenticating...", 'long', 'bottom');
                } catch (e) {
                    console.error(new Error(e));
                }
            } else {
                window.localStorage.api_credentials = 'Not authenticated';
                console.log('Not authenticated :(');
            }
            if(callback) callback(res);
        };
        var api_credentials = window.localStorage.api_credentials;

        if (typeof api_credentials === 'undefined' || force_show) {
            var confirmPopup = $ionicPopup.confirm({
                title: 'Duration Data Policy',
                template: "<style>.button-continue{background-color: #00b8e7;}</style><p>1self Duration uses the 1self cloud to show you smart visualizations of your activity. Once connected you can also share and correlate your data. Your raw data will never be shown and it won't be possible to tell who you are or where you've been. Would you like to connect Duration to the 1self cloud?</p>",
                buttons: [{
                    text: 'No thanks',
                    onTap: function(e) {
                        onConfirm(false);
                    }
                }, {
                    text: 'Continue',
                    type: 'button-continue',
                    onTap: function(e) {
                        onConfirm(true);
                    }
                }]
            });
        }
    },

    auth_headers = {
        'Authorization': API.appId + ":" + API.appSecret
    },
    registerStream = function() {
        $http.post(API.endpoint + "/v1/streams", {}, {
            headers: auth_headers
        })
            .success(function(data) {
                window.localStorage.api_credentials = angular.toJson(data);
                window.localStorage.last_event_sent_index = -1;

                //a continuous service to send pending events
                EventSendService.sendEvents();

        try {
            $cordovaToast.show("Authenticated", 'long', 'bottom')
        } catch (e) {
            console.error(new Error(e));
        }
            })
            .error(function(data, status, headers, config) {
                //try again next time :(
            });
    },

    authenticated = function() {
        var api_credentials = window.localStorage.api_credentials;
        return (api_credentials !== "Not authenticated") && (typeof api_credentials !== 'undefined');
    };

    return {
        authenticate: showDisclaimer,
        authenticated: authenticated
    };
});
angular.module('tracker')
	.controller('ChartCtrl', ChartCtrl);

function ChartCtrl() {
	var vm = this;
}
angular.module('tracker')
    .service('EventSendService', EventSendService);

function EventSendService($http, $timeout, API, $filter) {
    var getQueue = function() {
        var queueString = window.localStorage.events;
        if (queueString) {
            return angular.fromJson(queueString);
        } else {
            return [];
        }
    },

    queueEvent = function(activity) {
        var queue = getQueue();
        queue.push(activity);
        window.localStorage.events = angular.toJson(queue);
    },

    getLastSentIndex = function(){
        var last_event_sent_index = window.localStorage.last_event_sent_index;
        if(typeof last_event_sent_index === 'undefined'){
            return -1;
        }else{
            return parseInt(last_event_sent_index, 10);
        }
    },

    updateLastSentIndex = function(number_of_sent) {
        var last_index = getLastSentIndex(),
        new_last_sent_index = last_index + number_of_sent;
        window.localStorage.last_event_sent_index = new_last_sent_index;
    },


    getUnsentEvents = function() {
        var queue = getQueue(),
        last_event_sent_index = getLastSentIndex(),
        queue_length = queue.length;

        return queue.slice(last_event_sent_index + 1, queue_length);
    },

    sendEvents = function() {
        var api_credentials = angular.fromJson(window.localStorage.api_credentials),
        api_headers = {
            'Authorization': api_credentials.writeToken,
            'Content-Type': 'application/json'
        },

        buildAPIEvent = function(event) {
            // var tags = ActivitiesService.getTags(event.activity);
            return {
                "dateTime": event.dateTime,
                "source": API.appName,
                "version": API.appVersion,
                // "objectTags": tags.objectTags,
                // "actionTags": tags.actionTags,
                "properties": {
                    "duration": event.duration
                }
            };
        },

        lock = false,

        poller = function() {
            var api_events = [],
            events = getUnsentEvents();

            if (0 !== events.length) {
                for (i = 0; i < events.length; i++) {
                    api_events.push(buildAPIEvent(events[i]));
                }
                
            if (!lock) {
                lock = true;
                $http.post(API.endpoint + "/v1/streams/" + api_credentials.streamid + '/events/batch',
                        api_events, {
                            headers: api_headers
                        })
                    .success(function(data) {
                        updateLastSentIndex(api_events.length);
                        lock = false;
                    })
                    .error(function(data) {
                        lock = false;
                    });
            }
        }
            $timeout(poller, 2000);
        };

        poller();
    };

    return {
        queueEvent: queueEvent,
        sendEvents: sendEvents,
        getQueue: getQueue
    };
}
angular.module('tracker')
	.controller('HistoryCtrl', HistoryCtrl);

function HistoryCtrl(historyService, $filter) {
	var vm = this;

    vm.events = getEvents();
    vm.dates = Object.keys(getEvents()).sort().reverse();
    vm.humanizeTime = humanizeTime;
    vm.clearHistory = clearHistory;

    function humanizeTime(duration) {
        var tstring = $filter('millisecondsToStringFilter')(duration).split(':');
        return {
            hours: parseInt(tstring[0], 10),
            minutes: parseInt(tstring[1], 10),
            seconds: parseInt(tstring[2], 10)
        };
    };

    function getEvents() {
        var events = historyService.getQueue();
        var groups = {};
        events.forEach(function(event) {
            var date = event.when.split('T')[0];
            if (!groups[date]) {
                groups[date] = [];
            }

            // if is value and event with that event exists in groups[date]
            // add the value to existing value
            if (event.amount) {
                var sum = _.find(groups[date], { 'event': event.event });
                if (sum) {
                    sum.amount += event.amount;
                } else {                    
                    groups[date].unshift({event: event.event, amount:event.amount});
                }
            } else {
                groups[date].unshift(event);
            }
        });

        return groups;
    };

    function clearHistory() {
        historyService.clear();
        vm.events = getEvents();
    }
}
angular.module('tracker')
	.factory('historyService', historyService);

function historyService(preferenceService) {
	var history = JSON.parse(window.localStorage['history'] || '[]');
	var groupedEvents = {};

	return {
		getHistory: getHistory,
		add: add,
		getGroupedEvents: getGroupedEvents,
		getQueue: getQueue,
		queueEvent: queueEvent,
		setGroupedEvents: getGroupedEvents,
        clear: clear
	}

    function getQueue() {
        var queueString = window.localStorage.history;
        if (queueString) {
            return angular.fromJson(queueString);
        } else {
            return [];
        }
    }

    function queueEvent(activity) {
        var queue = getQueue();
        queue.push(activity);
        window.localStorage.history = angular.toJson(queue);
    }

	function getHistory() {
		return history;
	}

	function add(event) {
		event.when = new Date().toISOString();
		history.push(event);
		save();
		if (event.amount) {
            preferenceService.setLastAmountLogged(event.event, event.amount);
        }
	}

	function save() {
   		window.localStorage['history'] = JSON.stringify(history);
    }

    function getGroupedEvents() {
        var events = getQueue();
        var groups = {};
        events.forEach(function(event) {
            var date = event.when.split('T')[0];
            if (!groups[date]) {
                groups[date] = [];
            }

            // if is value and event with that event exists in groups[date]
            // add the value to existing value
            if (event.amount) {
            	var sum = _.find(groups[date], { 'event': event.event });
            	if (sum) {
            		sum.amount += event.amount;
            	} else {            		
	            	groups[date].unshift({event: event.event, amount:event.amount});
            	}
            } else {
	            groups[date].unshift(event);
            }

        });

        return groups;
    };

    function clear() {
        history = [];
        window.localStorage.history = [];
    }
}
angular.module('tracker')
    .factory('NotificationService', NotificationService);

function NotificationService($ionicPlatform){
    var id = "1";
    var count = 0;

    if (window.localStorage.active_activities) {
        count = Object.keys(angular.fromJson(window.localStorage.active_activities)).length;
    }

    return {
        showNotification: showNotification,
        cancelNotification: cancelNotification
    };

    function showNotification() {
        try {
            $ionicPlatform.ready(function() {
                count++;
                id = window.plugin.notification.local.add({
                    id: id,
                    title: 'Duration',
                    message: 'Timer active',
                    date: new Date(),
                    ongoing: true,
                    badge: count
                });
            });
        } catch (e) {
            console.error(new Error(e));
        }
    };

    function cancelNotification() {
        try {
            $ionicPlatform.ready(function() {
                count--;
                if (count === 0) {
                    window.plugin.notification.local.cancelAll();
                }
                else {
                    window.plugin.notification.local.add({
                        id: id,
                        title: 'Duration',
                        message: 'Timer active',
                        ongoing: true,
                        sound: null,
                        badge: count});
                }
            });
        } catch (e) {
            console.error(new Error(e));
        }
    };
}

angular.module('tracker')
	.factory('popupService', popupService);

function popupService($ionicPopup) {
	return {
		showAddActivityStep1: showAddActivityStep1,
		showAddActivityStep2: showAddActivityStep2
	};

	function showAddActivityStep1($scope, then) {
		var addPopupConfig = {
			title: 'Add a new activity',
			subTitle: 'What is the name of the activity?',
			templateUrl: 'templates/popup-name.html',
			scope: $scope,
			buttons: [{
				text: 'Cancel',
				onTap: function() {
					return null;
				}
			}, {
				text: 'Next',
				type: 'button-positive',
				onTap: function(e) {
					if (!$scope.vm.newActivity.name) {
						e.preventDefault();
					} else {
						return $scope.vm.newActivity.name;
					}
				}
			}]
		};

		$ionicPopup.show(addPopupConfig).then(then);
	}

	function showAddActivityStep2($scope, then) {
		var addPopupConfig2 = {
			title: 'Add a new activity',
			subTitle: 'What is the type of the activity?',
			templateUrl: 'templates/popup-add.html',
			scope: $scope,
			buttons: [{
				text: 'Cancel'
			}, {
				text: 'Add',
				type: 'button-positive',
				onTap: function() {
					if (!$scope.vm.newActivity.type) {
						e.preventDefault();
					}
				}
			}]
		};

		$ionicPopup.show(addPopupConfig2).then(then);
	}
}
angular.module('tracker')
	.factory('preferenceService', preferenceService);

function preferenceService() {
	var preferences = JSON.parse(window.localStorage.preferences || '{}');

	return {
		setLastAmountLogged: setLastAmountLogged,
		getLastAmountLogged: getLastAmountLogged
	}

	function setLastAmountLogged(activity, amount) {
		if (!preferences.lastAmountLogged) preferences.lastAmountLogged = {};

		preferences.lastAmountLogged[activity] = amount;
		save();
	}

	function getLastAmountLogged(activity) {
		if (!preferences.lastAmountLogged || !preferences.lastAmountLogged[activity]) {
			return 0;
		}

		return preferences.lastAmountLogged[activity];
	}

	function save() {
   		window.localStorage.preferences = JSON.stringify(preferences);
    }
}
angular.module('tracker')
    .filter('durationPartFilter', function() {
        return function(str) {
            return str.substr(0, 8);
        }
    })
    .filter('tenthsPartFilter', function() {
        return function(str) {
            return str.substr(9, str.length);
        }
    })
    .filter('buildEventFilter', function() {
        return function(activity) {
            return {
                "activity": activity.title,
                "dateTime": activity.startDate,
                "duration": activity.duration/1000
            };
        };
    });
angular.module('tracker')
    .filter('humanize', humanize);

function humanize(moment) {
    moment.locale('en', {
        calendar: {
            lastDay: '[Yesterday]',
            sameDay: '[Today]',
            lastWeek: '[Last] dddd LL',
            sameElse: 'LL'
        }
    });

    return function(date) {
        return moment(date).calendar();
    };
}
angular.module('tracker')
    .filter('millisecondsToStringFilter', millisecondsToStringFilter);

function millisecondsToStringFilter() {
    return function(milliseconds) {
        if (milliseconds !== 0 && !milliseconds) return "";

        var seconds = Math.floor(milliseconds / 1000);
        milliseconds = Math.floor((milliseconds % 1000) / 100);
        var minutes = Math.floor(seconds / 60);
        seconds = seconds - (minutes * 60);
        var hours = Math.floor(minutes / 60);
        minutes = minutes - (hours * 60);

        var zeroPad = function(num, numZeros) {
            var n = Math.abs(num);
            var zeros = Math.max(0, numZeros - Math.floor(n).toString().length);
            var zeroString = Math.pow(10, zeros).toString().substr(1);
            if (num < 0) {
                zeroString = '-' + zeroString;
            }
            return zeroString + n;
        }

        var durationString = '';
        durationString += zeroPad(hours, 2) + ':' + zeroPad(minutes, 2) + ':' + zeroPad(seconds, 2) + ":" + zeroPad(milliseconds, 2);
        return durationString;
    };
}
}());
